{"version":"1","records":[{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem"},"type":"lvl1","url":"/osnovno-preiskovanje","position":0},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem"},"content":"Preiskovalni algoritmi ponujajo splošni pristop k reševanju problemov. Ideja tega pristopa je preprosta: do rešitve problema pridemo s preiskovanjem prostora možnih rešitev. Prvi korak pri reševanju problemov s preiskovanjem je torej definiranje prostora stanj, ki ustrezajo možnim rešitvam. V drugem koraku izberemo preiskovalni algoritem in ga uporabimo na definiranem prostoru stanj zato, da dobimo pravo rešitev. V okviru predavanja bomo spoznali pojme iz prejšnjih dveh stavkov in vsebino tretjega poglavja z naslovom Solving Problems by Searching iz učbenika \n\nRussell & Norvig (2019).\n\nVzemimo za primer reševanje diofantska enačba 4 x_1 - 3 x_2 = 13 v množici naravnih števil. Možne rešitve podane enačbe so vsi možni pari naravnih števil. Primer prave rešitve je par \\left<4, 1\\right>. Pozor, to ni edina prava rešitev podane diofantska enačbe: koliko je pravih rešitev podane diofantska enačbe v množici naravnih števil?\n\n","type":"content","url":"/osnovno-preiskovanje","position":1},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Prostor stanj in rešitve"},"type":"lvl3","url":"/osnovno-preiskovanje#prostor-stanj-in-re-itve","position":2},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Prostor stanj in rešitve"},"content":"Prostor stanj\n\nProstor stanj za podan problem je četverica \\mathcal{S} = \\left< S, s_0, S_K, P \\right>, kjer je:\n\nS množica stanj, ki ustrezajo možnim rešitvam podanega problema;\n\ns_0 \\in S je začetno stanje;\n\nS_K \\subseteq S je množica končnih stanj, ki ustrezajo pravim rešitvam podanega problema;\n\nP je funkcija prehoda med stanji, ki preslika trenutno stanje s \\in S v množico parov \\left< t, c \\right>, pri čemer t \\in S predstavlja naslednje stanje v katero lahko preidemo iz stanja s in je c \\in \\mathbb{R}_{\\gt 0} cena tega prehoda.\n\nZa primer podane diofantske enačbe iz prejšnjega razdelka očitno velja S = \\mathbb{N} \\times \\mathbb{N}. Množico pravih rešitev lahko definiramo tudi tako, da nam ni treba podati seznama rešitev, s predpisom S_K = \\{ \\left< x_1, x_2 \\right> \\in S \\colon 4 x_1 - 3 x_2 = 13\\}. Taka definicija nam omogoča, da za podano možno rešitev preverimo, če je prava.\n\nZačetno stanje in funkcijo prehoda za ta primer lahko definiramo na različne načine. Oglejmo si enega od najbolj preprostih. Nastavimo začetno stanje na s_0 = \\left< 0, 0 \\right> (pri tem predmetu velja dogovor, da je 0 \\in \\mathbb{N}). Nato definiramo P(\\left< x_1, x_2 \\right>) = \\{ \\left< \\left< x_1 + 1, x_2 \\right>, 1 \\right>, \\left< \\left< x_1, x_2 + 1 \\right>, 1 \\right> \\}. Torej podanemu stanju, t.j., paru naravnih števil priredimo dve naslednji stanji (dvojici) tako, da najprej prvi nato pa še drugi element podanega stanja nadomestimo z naslednikom tega elementa v množici naravnih števil. Oba prehoda iz podanega v naslednjo stanje imata ceno 1.\n\nTako definiran prostor stanj zagotavlja, da iz začetnega stanja, s ponavljajočo se uporabo funkcije prehodov, lahko dosežemo poljubno stanje. Premisli kako pokažemo dosegljivost poljubnega stanja iz začetnega stanja \\left< 0, 0 \\right>. Namig: za podano stanje \\left< x_1, x_2 \\right> lahko našteješ prehode, ki pripeljejo iz začetnega do podanega stanja. Kakšna je skupna cena teh prehodov?\n\nDefinirajmo zdaj že omenjeno dosegljivost in pot v prostoru stanj bolj formalno.\n\nPot v prostoru stanj in cena poti\n\nPot v prostoru stanj \\mathcal{S} = \\left< S, s_0, S_K, P \\right> je zaporedje stanj p = s_0, s_1, s_2, \\dots, s_n, kjer za vsak 0 \\lt i \\le n velja \\left< s_i, c_i \\right> \\in P(s_{i-1}). Za pot p rečemo, da se začne v stanju s_0 in konča v stanju s_n. Cena \\textrm{cena}(p) poti p je definirana kot vsota cen vseh prehodov iz s_{i-1} v s_i, t.j., \\sum_{i = 1}^{n} c_i . Dolžina poti je enaka številu prehodov n.\n\nPozor, posebna pot dolžine (in cene) 0 je prazna pot p = s_0.\n\nOglejmo si zdaj še en primer prostora stanj, kjer dobi pojem pot v prostoru stanj svoj običajen slovarski pomen. Prostor stanj tokrat ustreza problemu načrtovanja poti po Romuniji. Slika \n\nFigure 1 prikazuje zemljevid cestnih povezav med mesti v Romuniji. Denimo, da smo trenutno v mestu Arad. S pomočjo zemljevida iščemo pot v Bukarešto. Dodatno si seveda želimo, da je ta pot čim krajša.\n\n\n\nFigure 1:Zemljevid Romunije.\n\nDefinirajmo zdaj štiri komponente prostora stanj za reševanje tega problema. Stanja v preiskovalnem prostoru bodo ustrezala mestom na zemljevidu Romunije. Začetno stanje ustreza mestu Arad. Končno stanje ustreza Bukarešti. Funkcija prehodov med stanji izhaja iz zemljevida. Tako, je, na primer P(\\textrm{Arad}) = \\{ \\left< \\textrm{Timisaora}, 118 \\right>, \\left< \\textrm{Zerind}, 75 \\right>, \\left< \\textrm{Sibiu}, 140 \\right> \\} ustreza dejstvu, ki ga preberemo iz zemljevida, da so z mestom Arad neposredno cestno povezana tri mesta v Romuniji: Timisaora (oddaljeno 118 kilometrov), Zarind (oddaljeno 75 kilometrov) in Sibiu (oddaljeno 140 kilometrov).\n\nPreden nadaljuješ z branjem, premisli kaj je možna in kaj je prava tega rešitev v tako zastavljenem prostoru stanj.\n\nDosegljivost stanja in prostora stanj\n\nStanje s \\in S iz prostora stanj \\mathcal{S} = \\left< S, s_0, S_K, P \\right> je dosegljivo, če obstaja pot p = s_0, s_1, \\dots, s, ki se konča v stanju s. Prostor stanj \\mathcal{S} je dosegljiv, če je vsako stanje s \\in S dosegljivo.\n\nPremisli zakaj je začetno stanje s_0 vedno dosegljivo. Premisli tudi katera lastnost grafa, ki jo poznamo iz teorije grafov, ustreza dosegljivost v prostoru stanj za problem potovanja po Romuniji.\n\nS pomočjo poti lahko definiramo (optimalno) rešitev v prostoru stanj.\n\nRešitev in optimalna rešitev v prostoru stanj\n\nRešitev v prostoru stanj \\mathcal{S} = \\left< S, s_0, S_K, P \\right> je pot r = s_0, s_1, \\dots, s_k, ki se konča v končnem stanju s_k \\in S_K. Cena in dolžina rešitve r sta enaki ceni in dolžini poti r. Optimalna rešitev je rešitev r z najmanjšo ceno, torej rešitev za katero velja, da imajo vse druge rešitve q v prostoru stanj \\mathcal{S} ceno, ki je višja od \\textrm{cena}(r), \\textrm{cena}(q) \\geq \\textrm{cena}(r).\n\nZa podano diofantsko enačbo je torej ena prava rešitev pot od stanja \\left< 0, 0 \\right> do stanja \\left< 4, 1 \\right>. Premisli kakšna je cena te rešitve in ali je ta rešitev optimalna. V primeru potovanja po Romuniji je prava rešitev katerakoli pot iz Arada v Bukarešto. Optimalna rešitev je najkrajša taka pot.\n\n","type":"content","url":"/osnovno-preiskovanje#prostor-stanj-in-re-itve","position":3},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Preiskovalno drevo in preiskovalna fronta"},"type":"lvl3","url":"/osnovno-preiskovanje#preiskovalno-drevo-in-preiskovalna-fronta","position":4},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Preiskovalno drevo in preiskovalna fronta"},"content":"Za preiskovanje prostora stanj uporabljamo preiskovalno drevo. Vozlišča v preiskovalnem drevesu ustrezajo stanjem, veje pa prehodom, ki jih definira funkcija prehodov. Vsaki veji pripišemo ceno prehoda. Vsakemu vozlišču pa pripišemo lastnost g, ki podaja seštevek cen vseh prehodov na poti od tega vozlišča do korena preiskovalnega drevesa.\n\nPreiskovalno drevo\n\nPreiskovalno drevo za prostor stanj \\mathcal{S} = \\left< S, s_0, S_K, P \\right> je drevo, kjer:\n\nvozlišča strezajo stanjem s \\in S;\n\nkorensko vozlišče je začetno stanje s_0;\n\notroci vozlišča s so vsa stanja s_1, s_2, \\dots, s_d \\in S za katera velja (s_i, c_i) \\in P(s);\n\nvsaka povezava med staršem s in otrokom s_i ustreza enemu prehodu iz stanja s v naslednje stanje;\n\nvejo med staršem s in otrokom s_i označimo s ceno prehoda c_i;\n\nvsakemu vozlišču s priredimo vrednost g(s), ki je enaka seštevku cen prehodov na drevesnih vejah od s do korenskega vozlišča s_0.\n\nGlobina preiskovalnega drevesa je maksimalno število vej na poteh od korenskega vozlišča do enega do končnih vozlišč.\n\nPozor, končna vozlišča v preiskovalnem drevesu niso nujno končna stanja, čeprav si delijo pridevnik končno. Lahko se pa zgodi, da končno vozlišče v drevesu (spomnimo se, da je to vozlišče brez otrok) ustreza končnemu stanju.\n\nPreiskovalna fronta, odprti in zaprti seznam\n\nKončnim vozliščem preiskovalnega drevesa, ki še niso razvejana, pravimo preiskovalna fronta. Vozlišča, ki so na preiskovalni fronti shranjujemo v odprti seznam. Že razvejana vozlišča, ki niso več na priskovalni fronti, shranjujemo v zaprti seznam.\n\nPreiskovalno drevo gradimo postopoma s ponavljanjem operacije razvejitve vozlišča, glej algoritem \n\nProgram 1. Začnemo s štorom, ki je drevo z enim vozliščem s_0, ki še ni razvejano (in je torej edino vozlišče na preiskovalni fronti oziroma v odprtem seznamu; na začetku gradnje je zaprti seznam prazen, glej vrstici 12 in 13). V vsakem koraku gradnje drevesa izberemo enega od vozlišč na preiskovalni fronti (iz odprtega seznama, glej vrstico 16), ki še ni razvejano, in ga razvejamo tako, da z uporabo funkcije prehodov določimo otroke in dodamo ustrezne veje drevesa (glej vrstice 27--30). Dodani otroci postanejo nova vozlišča v preiskovalnem drevesu, ki še niso razvejana, in so torej na preiskovalni fronti (pozor, vozlišče, ki ga razvejimo ni več na preiskovalni fronti in ga prestavimo v zaprti seznam, glej vrstico 25). Vlogo seznama zaprti pri razvejanju vozlišča (vrstica 29) bomo razložili pozneje.\n\nVHOD:\n  prostor_stanj      # definira stanja, začetno stanje, množico končnih stanj in funkcijo prehodov\n  strategija         # način izbire vozlišča za razvejanje iz odprtega seznama\n\nKLJUČNE PODATKOVNE STRUKTURE:\n  odprti             # odprti seznam (preiskovalna fronta) vozlišč, ki čakajo razvejanje\n  zaprti             # zaprti seznam že razvejanih vozlišč\n\nALGORITEM:\n  root ← Node(stanje = prostor_stanj.zacetno, stars = None, g = 0)\n\n  odprti ← { root }\n  zaprti ← ∅\n\n  while odprti ≠ ∅ do\n      v ← strategija.izberi(odprti)\n      odstrani v iz seznama odprti\n\n      if prostor_stanje.koncno(v.stanje) then\n          # poskus razvejanja vozlišča s končnim stanjem, vrnemo rešitev (pot od korenskega do tega vozlišča)\n          return POT(v)\n\n      if v.stanje ∉ zaprti then\n          # razvejaj vozlišče v\n          dodaj v.stanje v seznam zaprti\n\n          for each $(s, c)$ in prostor_stanj.funkcija_prehoda(v.stanje) do\n              otrok ← Node(stanje = s, stars = v, g = v.g + c)\n              if t ∉ zaprti and seznam odprti ne vsebuje vozlišča w: w.stanje = s in w.g < otrok.g then\n                  dodaj otrok v seznam odprti\n\n  return NEUSPEH\n\nProgram 1:Splošni preiskovalni algoritem, ki temelji na gradnji preiskovalnega drevesa\n\nPostopek gradnje preiskovalnega drevesa ustavimo takrat, ko poskušamo razvejati končno stanje (glej vrstice 19--21). V tem primeru se gradnja konča uspešno, saj smo našli rešitev, ki ustreza vejam preiskovalnega drevesa iz končnega stanja do korenskega vozlišča (ne pozabimo, da to ustreza začetnemu stanju). Gradnjo drevesa končamo tudi, če ni več vozlišč na preiskovalni fronti. V tem primeru se gradnja konča neuspešno (glej vrstici 15 in 32), saj taka situacija pomeni, da v postopku gradnje drevesa nismo našli poti do končnega stanja.\n\nPojasnimo zdaj še vlogo zaprtega seznama. Ta nam preprečuje nepotrebno zankanje pri preiskovanju. Namreč, če pri razvejanju vozlišča iz odprtega seznama dobimo stanje, ki je že v zaprtem seznamu, vemo, da smo to vozlišče že obiskali in ga ne dodamo v preiskovalno drevo (prvi del pogoja v vrstici 29). Tako se izognemo situaciji, ko bi se na eni veji preiskovalnega dreves večkrat pojavilo isto vozlišče. Ponavljanje je odveč, saj nam vračanje k stanju, ki smo ga že obiskali, po nepotrebnem podaljšuje pot k rešitvi. Ker so cene povezav pozitivne, nas tudi ne pelje k optimalni rešitvi. Drugi del pogoj v vrstici 29 preprečuje, da bi novo vozlišče ustrezalo stanju, ki je enako stanju drugega vozlišča v odprtem seznamu, hkrati pa bi vrednost g novega vozlišča bila višja. Tako zagotavljamo, da v odprtem seznamu ne ponavljamo po nepotrebnem vozlišča, ki ustrezajo istemu stanju, dodamo ga zgolj v primerih, ko vozlišče ima nižjo vrednost g.\n\nZa vajo zgradi (s papirjem in svinčnikom) preiskovalno drevo za reševanje diofantske enačbe z globino 4. Ponovi vajo za primer potovanja po Romuniji.\n\n","type":"content","url":"/osnovno-preiskovanje#preiskovalno-drevo-in-preiskovalna-fronta","position":5},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Osnovni preiskovalni algoritmi"},"type":"lvl3","url":"/osnovno-preiskovanje#osnovni-preiskovalni-algoritmi","position":6},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Osnovni preiskovalni algoritmi"},"content":"Postopku, ki smo ga opisali v prejšnjem razdelku rečemo splošni preiskovalni algoritem, kot je zapisano v naslovu \n\nProgram 1. En korak opisanega algoritma iz vrstice 16 še nismo pojasnili: kako izberemo vozlišče (stanje) iz odprtega seznama (preiskovalne fronte), ki ga bomo razvejali v naslednjem koraku algoritma? Načinu izbiranja vozlišča iz odprtega seznama rečemo preiskovalna strategija. Preiskovalni algoritmi se medsebojno razlikujejo ravno po uporabljeni preiskovalni strategiji. V nadaljevanju tega razdelka si bomo ogledali štiri osnovne strategije preiskovanja.","type":"content","url":"/osnovno-preiskovanje#osnovni-preiskovalni-algoritmi","position":7},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Preiskovanje v globino (Depth-First Search, DFS)","lvl3":"Osnovni preiskovalni algoritmi"},"type":"lvl4","url":"/osnovno-preiskovanje#preiskovanje-v-globino-depth-first-search-dfs","position":8},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Preiskovanje v globino (Depth-First Search, DFS)","lvl3":"Osnovni preiskovalni algoritmi"},"content":"Algoritem preiskovanja v globino za razvejanje izbere vozlišče na preiskovalni fronti, ki je najbolj globoko oziroma najbolj oddaljeno od korenskega vozliča preiskovalnega drevesa. To strategijo implementiramo tako, da je odprti seznam (preiskovalna fronta) organiziran kot sklad (angl. stack). Slednji je podatkovna struktura, pri kateri lahko elemente dodajamo in odstranjujemo le na enem koncu, zato deluje po načelu zadnji noter, prvi ven (angl. Last In, First Out, LIFO).\n\nPremisli zakaj sklad (načelo LIFO) zagotavlja, da bomo iz preiskovalne fronte izbrali najbolj globoko vozlišče na preiskovalni fronti.","type":"content","url":"/osnovno-preiskovanje#preiskovanje-v-globino-depth-first-search-dfs","position":9},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Preiskovanje v širino (Breadth-First Searh, BFS)","lvl3":"Osnovni preiskovalni algoritmi"},"type":"lvl4","url":"/osnovno-preiskovanje#preiskovanje-v-irino-breadth-first-searh-bfs","position":10},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Preiskovanje v širino (Breadth-First Searh, BFS)","lvl3":"Osnovni preiskovalni algoritmi"},"content":"Algoritem preiskovanja v globino za razvejanje izbere vozlišče na preiskovalni fronti, ki je najbolj plitvo oziroma najmanj oddaljeno od korenskega vozliča preiskovalnega drevesa. To strategijo implementiramo tako, da je odprti seznam (preiskovalna fronta) organiziran kot vrsta (angl. queue). Slednja je podatkovna struktura, pri kateri lahko elemente dodajamo na enem in odstranjujemo na drugem koncu, zato deluje po načelu prvi noter, prvi ven (angl. First In, First Out, FIFO).\n\nPremisli zakaj vrsta (načelo FIFO) zagotavlja, da bomo iz preiskovalne fronte izbrali najbolj plitvo vozlišče na preiskovalni fronti.","type":"content","url":"/osnovno-preiskovanje#preiskovanje-v-irino-breadth-first-searh-bfs","position":11},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Preiskovalni algoritem enotne cene (uniform-cost search)","lvl3":"Osnovni preiskovalni algoritmi"},"type":"lvl4","url":"/osnovno-preiskovanje#preiskovalni-algoritem-enotne-cene-uniform-cost-search","position":12},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Preiskovalni algoritem enotne cene (uniform-cost search)","lvl3":"Osnovni preiskovalni algoritmi"},"content":"Preiskovalni algoritem enotne cene za razvejanje izbere stanje s na preiskovalni fronti, ki ima najmanjšo vrednost g(s).\nTo strategijo implementiramo tako, da je odprti seznam organiziran kot kopica (angl. heap). Slednja je podatkovna struktura, ki omogoča hiter dostop do najmanjšega ali največjega elementa, saj zagotavlja, da bo ta element na najbolj dostopnem mestu.\n\nPremisli zakaj je kopica ustrezen način implementacije preiskovalne strategije enotne cene.","type":"content","url":"/osnovno-preiskovanje#preiskovalni-algoritem-enotne-cene-uniform-cost-search","position":13},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Primerjava učinkovitosti osnovnih preiskovalnih algoritmov","lvl3":"Osnovni preiskovalni algoritmi"},"type":"lvl4","url":"/osnovno-preiskovanje#primerjava-u-inkovitosti-osnovnih-preiskovalnih-algoritmov","position":14},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Primerjava učinkovitosti osnovnih preiskovalnih algoritmov","lvl3":"Osnovni preiskovalni algoritmi"},"content":"Lastnosti preiskovalnih algoritmov: polnost (completness) in optimalnost (optimality). Časovne in prostorske zahtevnosti glede na dimenzije prostora stanj (stopnja razvejanosti, globina rešitve, najdaljša pot v prostoru stanj). Tabela, primerjava in opozorilo o resnosti eksponentne časovne in prostorske zahtevnosti.\n\n","type":"content","url":"/osnovno-preiskovanje#primerjava-u-inkovitosti-osnovnih-preiskovalnih-algoritmov","position":15},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Hevristično preiskovanje"},"type":"lvl3","url":"/osnovno-preiskovanje#hevristi-no-preiskovanje","position":16},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Hevristično preiskovanje"},"content":"Kako preseči eksponentno zahtevnost? S pravilom palca, ki ga uporabljamo pri približnem reševanju zelo zahtevnih problemov. Pravilo palca je neka intuicija o tem katera rešitev bi bila boljša, še preden jo preverimo. Torej pravilo palca nam lahko pove katero stanje iz preiskovalne fronte se splača najprej razvejati.","type":"content","url":"/osnovno-preiskovanje#hevristi-no-preiskovanje","position":17},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Hevristična funkcija ali hevristika","lvl3":"Hevristično preiskovanje"},"type":"lvl4","url":"/osnovno-preiskovanje#hevristi-na-funkcija-ali-hevristika","position":18},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Hevristična funkcija ali hevristika","lvl3":"Hevristično preiskovanje"},"content":"Pričakovana (ocenjena) cena poti od trenutnega stanja s do enega od končnih stanj. Oznaka h(s). Formalna definicija?","type":"content","url":"/osnovno-preiskovanje#hevristi-na-funkcija-ali-hevristika","position":19},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Požrešen algoritem najprej najboljši in algoritem A^{*}","lvl3":"Hevristično preiskovanje"},"type":"lvl4","url":"/osnovno-preiskovanje#po-re-en-algoritem-najprej-najbolj-i-in-algoritem-a","position":20},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Požrešen algoritem najprej najboljši in algoritem A^{*}","lvl3":"Hevristično preiskovanje"},"content":"Najprej najboljši je min h(s). A^{*} je min g(s)+h(s).","type":"content","url":"/osnovno-preiskovanje#po-re-en-algoritem-najprej-najbolj-i-in-algoritem-a","position":21},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Sprejemljiva hevristika in optimalnost algoritma A^{*}","lvl3":"Hevristično preiskovanje"},"type":"lvl4","url":"/osnovno-preiskovanje#sprejemljiva-hevristika-in-optimalnost-algoritma-a","position":22},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl4":"Sprejemljiva hevristika in optimalnost algoritma A^{*}","lvl3":"Hevristično preiskovanje"},"content":"Definiramo h^{*}(s). Sprejemljiva hevristika h(s) \\leq h^{*}(s). Dokaz, da je v tem primeru prva rešitev, ki jo najde A^{*} optimalna.\n\n","type":"content","url":"/osnovno-preiskovanje#sprejemljiva-hevristika-in-optimalnost-algoritma-a","position":23},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl2":"Implementacija preiskovalnih algoritmov"},"type":"lvl2","url":"/osnovno-preiskovanje#implementacija-preiskovalnih-algoritmov","position":24},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl2":"Implementacija preiskovalnih algoritmov"},"content":"\n\nfrom pathlib import Path\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nROOT = Path.cwd().resolve().parent\nMATERIALI = ROOT / \"materiali\"\n\n\n\n\ndf = pd.read_csv(MATERIALI / \"podatki.csv\")\ndf\n\n\n\n\nplt.figure()\nplt.plot(df[\"x\"], df[\"y\"])\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Graf iz podatki.csv\")\nplt.show()\n\n\n\n\nimg = mpimg.imread(MATERIALI / \"lorem-ipsum.jpg\")\n\nplt.figure()\nplt.imshow(img)\nplt.axis(\"off\")\nplt.title(\"Slika iz mape materiali/\")\nplt.show()\n\n\n\n\n","type":"content","url":"/osnovno-preiskovanje#implementacija-preiskovalnih-algoritmov","position":25},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Literatura","lvl2":"Implementacija preiskovalnih algoritmov"},"type":"lvl3","url":"/osnovno-preiskovanje#literatura","position":26},{"hierarchy":{"lvl1":"Reševanje problemov s preiskovanjem","lvl3":"Literatura","lvl2":"Implementacija preiskovalnih algoritmov"},"content":"","type":"content","url":"/osnovno-preiskovanje#literatura","position":27},{"hierarchy":{"lvl1":"Preiskovanje v igrah"},"type":"lvl1","url":"/preiskovanje-v-igrah","position":0},{"hierarchy":{"lvl1":"Preiskovanje v igrah"},"content":"Nisem še.","type":"content","url":"/preiskovanje-v-igrah","position":1},{"hierarchy":{"lvl1":"Uvod v umetno inteligenco"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Uvod v umetno inteligenco"},"content":"Pravila igre\n\npisni izpit, uspešno opravljen, če je dosežek več kot 50 odstotnih točk\n\ndomače naloge za bonus točke\n\nustni izpit, pogoj za pristop je uspešno opravljen pisni izpit","type":"content","url":"/","position":1}]}